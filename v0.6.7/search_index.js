var documenterSearchIndex = {"docs":
[{"location":"reference/#API-reference-1","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"reference/#time-axes-1","page":"API reference","title":"time axes","text":"","category":"section"},{"location":"reference/#","page":"API reference","title":"API reference","text":"timeaxis\nistimeaxis\ntimedim\nHasTimeAxis\nTimeAxis","category":"page"},{"location":"reference/#ImageAxes.timeaxis","page":"API reference","title":"ImageAxes.timeaxis","text":"timeaxis(A)\n\nReturn the time axis, if present, of the array A, and nothing otherwise.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageAxes.istimeaxis","page":"API reference","title":"ImageAxes.istimeaxis","text":"istimeaxis(ax)\n\nTest whether the axis ax corresponds to time.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageAxes.timedim","page":"API reference","title":"ImageAxes.timedim","text":"timedim(img) -> d::Int\n\nReturn the dimension of the array used for encoding time, or 0 if not using an axis for this purpose.\n\nNote: if you want to recover information about the time axis, it is generally better to use timeaxis.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageAxes.HasTimeAxis","page":"API reference","title":"ImageAxes.HasTimeAxis","text":"HasTimeAxis{AA}\n\nA trait for testing whether type AA has a time axis. Time axes must be declared before use.\n\nExamples\n\nusing ImageAxes, SimpleTraits\n\n# Declare that all axes named `:time` are time axes\n@traitimpl TimeAxis{Axis{:time}}\n\n# Define functions that dispatch on AxisArrays that may or may not have time axes\n@traitfn got_time{AA<:AxisArray;  HasTimeAxis{AA}}(img::AA) = \"yep, I've got time\"\n@traitfn got_time{AA<:AxisArray; !HasTimeAxis{AA}}(img::AA) = \"no, I'm too busy\"\n\njulia> A = AxisArray(1:5, Axis{:time}(1:5));\n\njulia> got_time(A)\n\"yep, I've got time\"\n\njulia> A = AxisArray(1:5, Axis{:x}(1:5));\n\njulia> got_time(A)\n\"no, I'm too busy\"\n\n\n\n\n\n","category":"type"},{"location":"reference/#ImageAxes.TimeAxis","page":"API reference","title":"ImageAxes.TimeAxis","text":"TimeAxis{Ax}\n\nA trait (from SimpleTraits) indicating whether axis Ax corresponds to time. This decision is based on the symbol-name given to Ax. For example, the following declares that all Axis{:time} objects correspond to time:\n\n@traitimpl TimeAxis{Axis{:time}}\n\nThis definition has already been made in ImageAxes, but you can add new names as well.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Streaming-container-1","page":"API reference","title":"Streaming container","text":"","category":"section"},{"location":"reference/#","page":"API reference","title":"API reference","text":"StreamingContainer\nStreamIndexStyle\nIndexAny\nIndexIncremental","category":"page"},{"location":"reference/#ImageAxes.StreamingContainer","page":"API reference","title":"ImageAxes.StreamingContainer","text":"A = StreamingContainer{T}(f!, parent, streamingaxes::Axis...)\n\nAn array-like object possessing one or more axes for which changing \"slices\" may be expensive or subject to restrictions. A canonical example would be an AVI stream, where addressing pixels within the same frame is fast but jumping between frames might be slow.\n\nHere's a simple example of dividing by the mean of each slice of an image before returning values.\n\nA = AxisArrays.AxisArray(reshape(1:36, 3, 3, 4))\n\nfunction f!(buffer, slice)\n    meanslice = mean(slice)\n    buffer .= slice./meanslice\nend\n\nB = StreamingContainer{Float64}(f!, A, AxisArrays.axes(A)[3])\n\njulia> A[:,:,1]\n3×3 AxisArray{Int64,2,Array{Int64,2},Tuple{Axis{:row,Base.OneTo{Int64}},Axis{:col,Base.OneTo{Int64}}}}:\n 1  4  7\n 2  5  8\n 3  6  9\n\njulia> B[:,:,1]\n3×3 Array{Float64,2}:\n 0.2  0.8  1.4\n 0.4  1.0  1.6\n 0.6  1.2  1.8\n\nThe user-provided f! function should take arguments:\n\nf!(buffer, slice)\n\nWhere buffer will be an empty array that can hold a slice of your series, and slice will hold the current input slice.\n\nIt's worth noting that StreamingContainer is not a subtype of AbstractArray, but that much of the array interface (eltype, ndims, axes, size, getindex, and IndexStyle) is supported. A StreamingContainer A can be built from an AxisArray, but it may also be constructed from other \"parent\" objects, even non-arrays, as long as they support the same functions. In either case, the parent should also support the standard AxisArray functions axes, axisnames, axisvalues, and axisdim; this support will be extended to the StreamingContainer.\n\nAdditionally, a StreamingContainer A supports\n\ngetindex!(dest, A, axt::Axis{:time}, ...)\n\nto obtain slices along the streamed axes (here it is assumed that :time is a streamed axis of A). You can implement this directly (dispatching on the parameters of A), or (if the parent is an AbstractArray) rely on the fallback\n\nA.getindex!(dest, view(parent, axs...))\n\nwhere A.getindex! = f! as passed as an argument at construction. dest should have dimensionality ndims(parent)-length(streamingaxes).\n\nOptionally, define StreamIndexStyle(typeof(parent),typeof(f!)).\n\n\n\n\n\n","category":"type"},{"location":"reference/#ImageAxes.StreamIndexStyle","page":"API reference","title":"ImageAxes.StreamIndexStyle","text":"style = StreamIndexStyle(A)\n\nA trait that indicates the degree of support for indexing the streaming axes of A. Choices are IndexAny() and IndexIncremental() (for arrays that only permit advancing the time axis, e.g., a video stream from a webcam). The default value is IndexAny().\n\nThis should be specialized for the type rather than the instance. For a StreamingContainer S, you can define this trait via\n\nStreamIndexStyle(::Type{P}, ::typeof(f!)) = IndexIncremental()\n\nwhere P = typeof(parent(S)).\n\n\n\n\n\n","category":"type"},{"location":"reference/#ImageAxes.IndexAny","page":"API reference","title":"ImageAxes.IndexAny","text":"IndexAny()\n\nIndicates that an axis supports full random-access indexing.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ImageAxes.IndexIncremental","page":"API reference","title":"ImageAxes.IndexIncremental","text":"IndexIncremental()\n\nIndicates that an axis supports only incremental indexing, i.e., from i to i+1. This is commonly used for the temporal axis with media streams.\n\n\n\n\n\n","category":"type"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"While images can often be represented as plain Arrays, sometimes additional information about the \"meaning\" of each axis of the array is needed.  For example, in a 3-dimensional MRI scan, the voxels may not have the same spacing along the z-axis that they do along the x- and y-axes, and this fact should be accounted for during the display and/or analysis of such images.  Likewise, a movie has two spatial axes and one temporal axis; this fact may be relevant for how one performs image processing.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"This package combines features from AxisArrays and SimpleTraits to provide a convenient representation and programming paradigm for dealing with such images.","category":"page"},{"location":"#Installation-1","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pkg.add(\"ImageAxes\")","category":"page"},{"location":"#Usage-1","page":"Introduction","title":"Usage","text":"","category":"section"},{"location":"#Names-and-locations-1","page":"Introduction","title":"Names and locations","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The simplest thing you can do is to provide names to your image axes:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"using ImageAxes\nimg = AxisArray(reshape(1:192, (8,8,3)), :x, :y, :z)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"As described in more detail in the AxisArrays documentation, you can now take slices like this:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"sl = img[Axis{:z}(2)]\nsl = img[z=2]    # with AxisArrays 0.4.2 or higher","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"You can also give units to the axes:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"using ImageAxes, Unitful\nconst mm = u\"mm\"\nimg = AxisArray(reshape(1:192, (8,8,3)),\n                Axis{:x}(1mm:1mm:8mm),\n                Axis{:y}(1mm:1mm:8mm),\n                Axis{:z}(2mm:3mm:8mm))","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"which specifies that x and y have spacing of 1mm and z has a spacing of 3mm, as well as the location of the center of each voxel.","category":"page"},{"location":"#Temporal-axes-1","page":"Introduction","title":"Temporal axes","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Any array possessing an axis Axis{:time} will be recognized as having a temporal dimension.  Given an array A,","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"using ImageAxes, Unitful\nconst s = u\"s\"\nimg = AxisArray(reshape(1:9*300, (3,3,300)),\n                Axis{:x}(1:3),\n                Axis{:y}(1:3),\n                Axis{:time}(1s/30:1s/30:10s))","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"you can retrieve its temporal axis with","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"ax = timeaxis(img)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"and index it like","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"img[ax(4)]  # returns the 4th \"timeslice\"","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"You can also specialize methods like this:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"using ImageAxes, SimpleTraits\n@traitfn nimages(img::AA) where {AA<:AxisArray;  HasTimeAxis{AA}} = length(timeaxis(img))\n@traitfn nimages(img::AA) where {AA<:AxisArray; !HasTimeAxis{AA}} = 1","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"where the pre-defined HasTimeAxis trait will restrict that method to arrays that have a timeaxis. A more complex example is","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"using ImageAxes, SimpleTraits\n@traitfn meanintensity(img::AA) where {AA<:AxisArray; !HasTimeAxis{AA}} = mean(img)\n@traitfn function meanintensity(img::AA) where {AA<:AxisArray; HasTimeAxis{AA}}\n    ax = timeaxis(img)\n    n = length(x)\n    intensity = zeros(eltype(img), n)\n    for ti = 1:n\n        sl = img[ax[ti]]  # the image slice at time ax[ti]\n        intensity[ti] = mean(sl)\n    end\n    intensity\nend","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"and, when appropriate, it will return the mean intensity at each timeslice.","category":"page"},{"location":"#Custom-temporal-axes-1","page":"Introduction","title":"Custom temporal axes","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Using SimpleTraits's @traitimpl, you can add Axis{:t} or Axis{:scantime} or any other name to the list of axes that have a temporal dimension:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"using ImageAxes, SimpleTraits\n@traitimpl TimeAxis{Axis{:t}}","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Note this declaration affects all arrays throughout your entire session.  Moreover, it should be made before calling any functions on array-types that possess such axes; a convenient place to do this is right after you say using ImageAxes in your top-level script.","category":"page"},{"location":"#StreamingContainer-1","page":"Introduction","title":"StreamingContainer","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"ImageAxes implements a non-AbstractArray type StreamingContainer for handling streaming media or computationally-generated images. It provides much of the interface of AbstractArrays without the implicit promise of random access or efficient indexing for all axes.","category":"page"}]
}
